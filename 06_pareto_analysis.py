"""
06: Pareto front analysis of Sobol samples.

This script:
1. Loads objective metric values for all samples
2. Identifies non-dominated solutions to find the Pareto front
3. Plots Pareto front solutions in metric space and parameter space

Usage:
    python 06_pareto_analysis.py
"""

import sys
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from pathlib import Path

# Add methods to path
sys.path.insert(0, str(Path(__file__).parent))

from datetime import timedelta

from config import (
    METRICS_TO_CALCULATE,
    FIGURES_DIR,
    ANALYSIS_DIR,
    SIMULATIONS_DIR,
    get_active_parameters,
    get_parameter_group,
    ZONE_LEVELS_ORDERED,
    NYC_RESERVOIRS,
    NYC_TOTAL_CAPACITY,
)
from methods.sampling import load_samples, sample_to_nyc_config
from methods.metrics import load_metrics, calculate_sample_metrics, load_simulation_data
from methods.plotting import custom_parallel_coordinates
from pywrdrb.parameters.nyc_operations_config import NYCOperationsConfig

# =============================================================================
# SCRIPT SETTINGS
# =============================================================================
# Define objectives and their optimization direction
# True = maximize (higher is better), False = minimize (lower is better)
OBJECTIVES = {
    "montague_flow_3day_min_mgd": True,   # Maximize 3-day min flow (higher = better for ecology)
    "nyc_min_storage_pct": True,          # Maximize minimum storage (higher = better for supply)
    "max_nyc_monthly_shortage_pct": False, # Minimize maximum monthly shortage (lower = better reliability)
    "pct_time_drought_emergency": False,  # Minimize time in drought emergency
}

# Path to baseline simulation output (generated by 00_generate_presimulated_releases.py)
from config import PRESIM_DIR
BASELINE_OUTPUT_FILE = PRESIM_DIR / "full_model_baseline_output.hdf5"

# Plot settings
DPI = 150
plt.rcParams['figure.facecolor'] = 'white'
plt.rcParams['axes.facecolor'] = 'white'
plt.rcParams['font.size'] = 9


# =============================================================================
# BASELINE METRICS
# =============================================================================

def get_baseline_metrics(objective_names):
    """
    Get metrics for the baseline (default parameters) simulation.

    First tries to load from saved CSV (faster). If not available,
    calculates from the baseline output HDF5 file.

    Parameters
    ----------
    objective_names : list
        List of objective/metric names to retrieve

    Returns
    -------
    dict or None
        Dictionary of {metric_name: value} or None if baseline not available
    """
    from config import METRICS_DIR

    # First try to load from saved CSV (faster)
    baseline_csv = METRICS_DIR / "baseline_metrics.csv"
    if baseline_csv.exists():
        try:
            import pandas as pd
            baseline_df = pd.read_csv(baseline_csv)
            baseline_metrics = baseline_df.iloc[0].to_dict()
            # Filter to requested objectives
            return {k: v for k, v in baseline_metrics.items() if k in objective_names}
        except Exception as e:
            print(f"  Error loading baseline CSV: {e}, falling back to HDF5...")

    # Fall back to calculating from HDF5
    if not BASELINE_OUTPUT_FILE.exists():
        print("  Baseline output not found. Run 00_generate_presimulated_releases.py first.")
        print(f"    Expected: {BASELINE_OUTPUT_FILE}")
        return None

    try:
        metrics = calculate_sample_metrics(
            sample_id=-1,  # Use -1 to indicate baseline
            output_file=str(BASELINE_OUTPUT_FILE),
            metrics=objective_names
        )
        # Remove sample_id from results
        return {k: v for k, v in metrics.items() if k != 'sample_id'}
    except Exception as e:
        print(f"  Error loading baseline metrics: {e}")
        return None


# =============================================================================
# PARETO FRONT IDENTIFICATION
# =============================================================================

def is_dominated(point, other_points, maximize_flags):
    """
    Check if a point is dominated by any point in other_points.

    A point is dominated if another point is at least as good in all objectives
    and strictly better in at least one.

    Parameters
    ----------
    point : np.ndarray
        Objective values for the point being tested
    other_points : np.ndarray
        Objective values for all other points (n_points x n_objectives)
    maximize_flags : np.ndarray
        Boolean array indicating which objectives to maximize

    Returns
    -------
    bool : True if point is dominated
    """
    # Convert to minimization problem (negate maximization objectives)
    point_min = np.where(maximize_flags, -point, point)
    others_min = np.where(maximize_flags, -other_points, other_points)

    # Check if any other point dominates this one
    for other in others_min:
        # Other is at least as good in all objectives
        at_least_as_good = np.all(other <= point_min)
        # Other is strictly better in at least one objective
        strictly_better = np.any(other < point_min)

        if at_least_as_good and strictly_better:
            return True

    return False


def find_pareto_front(objectives_df, objective_names, maximize_flags):
    """
    Find the Pareto front (non-dominated solutions).

    Parameters
    ----------
    objectives_df : pd.DataFrame
        DataFrame with objective values
    objective_names : list
        Column names for objectives
    maximize_flags : list
        Boolean list indicating which objectives to maximize

    Returns
    -------
    np.ndarray : Boolean mask for Pareto-optimal solutions
    """
    n_points = len(objectives_df)
    objectives = objectives_df[objective_names].values
    maximize_flags = np.array(maximize_flags)

    is_pareto = np.ones(n_points, dtype=bool)

    for i in range(n_points):
        if not is_pareto[i]:
            continue

        # Get indices of other points still considered Pareto
        other_indices = np.where(is_pareto)[0]
        other_indices = other_indices[other_indices != i]

        if len(other_indices) == 0:
            continue

        other_points = objectives[other_indices]

        if is_dominated(objectives[i], other_points, maximize_flags):
            is_pareto[i] = False

    return is_pareto


# =============================================================================
# PLOTTING FUNCTIONS
# =============================================================================

# Axis label formatting for parallel coordinates
AXIS_LABELS = {
    "montague_flow_3day_min_mgd": "Montague Flow\n3-day Min (MGD)",
    "nyc_min_storage_pct": "NYC Min Storage\n(%)",
    "max_nyc_monthly_shortage_pct": "Max NYC Monthly\nShortage (%)",
    "pct_time_drought_emergency": "% Time Drought\nEmergency",
}


def plot_objectives_parallel_coordinates(metrics_df, pareto_mask, objective_names,
                                         maximize_flags, baseline_metrics=None,
                                         figsize=(12, 6)):
    """
    Plot parallel coordinates for all objectives showing Pareto front.

    Uses custom parallel coordinates with actual value annotations.

    Parameters
    ----------
    metrics_df : pd.DataFrame
        DataFrame with metric values
    pareto_mask : np.ndarray
        Boolean mask for Pareto-optimal solutions
    objective_names : list
        List of objective column names
    maximize_flags : list
        List of booleans for maximization direction
    baseline_metrics : dict, optional
        Dictionary of baseline metric values {metric_name: value}
    figsize : tuple
        Figure size

    Returns
    -------
    matplotlib.figure.Figure
    """
    # Build DataFrame for plotting
    plot_df = metrics_df[objective_names].copy()

    # Add highlight column for categorical coloring
    plot_df["highlight"] = "Other"
    plot_df.loc[pareto_mask, "highlight"] = "Pareto"

    # Add baseline row if provided
    if baseline_metrics is not None:
        baseline_row = {name: baseline_metrics.get(name, np.nan)
                       for name in objective_names}
        baseline_row["highlight"] = "Baseline"
        baseline_df = pd.DataFrame([baseline_row])
        plot_df = pd.concat([plot_df, baseline_df], ignore_index=True)

    # Convert maximize_flags to minmaxs format
    minmaxs = ["max" if m else "min" for m in maximize_flags]

    # Get readable axis labels
    axis_labels = [AXIS_LABELS.get(name, name.replace("_", "\n"))
                   for name in objective_names]

    # Color dictionary
    color_dict = {
        "Other": "gray",
        "Pareto": "#2ca02c",  # green
        "Baseline": "#1f77b4",  # blue
    }

    fig = custom_parallel_coordinates(
        objs=plot_df,
        columns_axes=objective_names,
        axis_labels=axis_labels,
        ideal_direction="top",
        minmaxs=minmaxs,
        color_by_categorical="highlight",
        color_dict_categorical=color_dict,
        alpha_base=0.8,
        alpha_other=0.08,
        lw_base=1.8,
        fontsize=11,
        figsize=figsize,
        title="Pareto Front in Objective Space"
    )

    return fig


def plot_parameters_parallel_coordinates(samples, pareto_mask, problem,
                                         figsize=(14, 6)):
    """
    Plot parallel coordinates for Pareto front solutions in parameter space.

    Parameters
    ----------
    samples : np.ndarray
        Parameter samples array
    pareto_mask : np.ndarray
        Boolean mask for Pareto-optimal solutions
    problem : dict
        SALib problem definition
    figsize : tuple
        Figure size
    """
    fig, ax = plt.subplots(figsize=figsize)

    param_names = problem['names']
    bounds = np.array(problem['bounds'])
    n_params = len(param_names)

    # Normalize samples to [0, 1] based on bounds
    samples_norm = (samples - bounds[:, 0]) / (bounds[:, 1] - bounds[:, 0])

    # Plot dominated solutions (gray, thin)
    for i in np.where(~pareto_mask)[0]:
        ax.plot(range(n_params), samples_norm[i],
                color='gray', alpha=0.05, linewidth=0.5)

    # Plot Pareto solutions (red)
    pareto_samples = samples_norm[pareto_mask]

    for sample in pareto_samples:
        ax.plot(range(n_params), sample, color='red', alpha=0.6, linewidth=1.5)

    # Formatting
    ax.set_xticks(range(n_params))
    ax.set_xticklabels(param_names, rotation=45, ha='right', fontsize=8)
    ax.set_ylabel('Normalized Parameter Value', fontsize=10)
    ax.set_title('Pareto Front Solutions in Parameter Space\n(gray=dominated, red=Pareto)', fontsize=11)
    ax.set_ylim(-0.05, 1.05)
    ax.grid(True, alpha=0.3, axis='y')

    plt.tight_layout()
    return fig


def plot_parameter_boxplots(samples, pareto_mask, problem, figsize=(14, 6)):
    """
    Plot boxplots comparing parameter distributions: Pareto vs dominated.

    Parameters
    ----------
    samples : np.ndarray
        Parameter samples array
    pareto_mask : np.ndarray
        Boolean mask for Pareto-optimal solutions
    problem : dict
        SALib problem definition
    figsize : tuple
        Figure size
    """
    fig, ax = plt.subplots(figsize=figsize)

    param_names = problem['names']
    bounds = np.array(problem['bounds'])
    n_params = len(param_names)

    # Normalize samples to [0, 1]
    samples_norm = (samples - bounds[:, 0]) / (bounds[:, 1] - bounds[:, 0])

    pareto_samples = samples_norm[pareto_mask]
    dominated_samples = samples_norm[~pareto_mask]

    positions = np.arange(n_params)
    width = 0.35

    # Box plots
    bp1 = ax.boxplot([dominated_samples[:, i] for i in range(n_params)],
                     positions=positions - width/2, widths=width,
                     patch_artist=True, showfliers=False)
    bp2 = ax.boxplot([pareto_samples[:, i] for i in range(n_params)],
                     positions=positions + width/2, widths=width,
                     patch_artist=True, showfliers=False)

    # Colors
    for patch in bp1['boxes']:
        patch.set_facecolor('lightgray')
    for patch in bp2['boxes']:
        patch.set_facecolor('salmon')

    ax.set_xticks(positions)
    ax.set_xticklabels(param_names, rotation=45, ha='right', fontsize=8)
    ax.set_ylabel('Normalized Parameter Value', fontsize=10)
    ax.set_title('Parameter Distributions: Dominated (gray) vs Pareto (red)', fontsize=11)
    ax.set_ylim(-0.05, 1.05)
    ax.grid(True, alpha=0.3, axis='y')

    plt.tight_layout()
    return fig


# =============================================================================
# BEST SOLUTION ANALYSIS - FFMP ZONES AND MRF REQUIREMENTS
# =============================================================================

def find_best_solutions_per_objective(metrics_df, objective_names, maximize_flags):
    """
    Find the best solution index for each objective.

    Parameters
    ----------
    metrics_df : pd.DataFrame
        DataFrame with metric values
    objective_names : list
        List of objective names
    maximize_flags : list
        List of booleans (True = maximize, False = minimize)

    Returns
    -------
    dict : {objective_name: sample_index}
    """
    best_solutions = {}
    for obj_name, maximize in zip(objective_names, maximize_flags):
        if maximize:
            best_idx = metrics_df[obj_name].idxmax()
        else:
            best_idx = metrics_df[obj_name].idxmin()
        best_solutions[obj_name] = best_idx
    return best_solutions


def get_config_for_sample(sample_values, problem):
    """
    Get NYCOperationsConfig for a given sample.

    Parameters
    ----------
    sample_values : np.ndarray
        Parameter values for the sample
    problem : dict
        SALib problem definition

    Returns
    -------
    NYCOperationsConfig
    """
    return sample_to_nyc_config(sample_values, problem)


def get_baseline_config():
    """
    Get baseline NYCOperationsConfig (default parameters).

    Returns
    -------
    NYCOperationsConfig
    """
    return NYCOperationsConfig.from_defaults()


def plot_ffmp_zones_and_mrf(sample_config, baseline_config, objective_name,
                             objective_value, figsize=(14, 10)):
    """
    Plot FFMP storage zones and MRF requirements comparing sample to baseline.

    Parameters
    ----------
    sample_config : NYCOperationsConfig
        Configuration for the sample solution
    baseline_config : NYCOperationsConfig
        Configuration for the baseline (default parameters)
    objective_name : str
        Name of the objective this solution is best for
    objective_value : float
        Value of the objective for this solution
    figsize : tuple
        Figure size

    Returns
    -------
    matplotlib.figure.Figure
    """
    fig, axes = plt.subplots(2, 1, figsize=figsize, height_ratios=[1.5, 1])

    # Day of year for x-axis
    days = np.arange(1, 367)

    # Define colors for each zone level
    zone_colors = {
        'level1b': '#1a237e',   # Dark blue - Flood Warning
        'level1c': '#3949ab',   # Blue - Flood Watch
        'level2': '#43a047',    # Green - Normal
        'level3': '#fdd835',    # Yellow - Drought Watch
        'level4': '#ff9800',    # Orange - Drought Warning
        'level5': '#d32f2f',    # Red - Drought Emergency
    }

    zone_labels = {
        'level1b': 'Flood Warning',
        'level1c': 'Flood Watch',
        'level2': 'Normal',
        'level3': 'Drought Watch',
        'level4': 'Drought Warning',
        'level5': 'Drought Emergency',
    }

    # =========================================================================
    # Top subplot: FFMP Storage Zones
    # =========================================================================
    ax1 = axes[0]

    # Plot baseline zones (dashed)
    for level in ZONE_LEVELS_ORDERED:
        baseline_profile = baseline_config.get_storage_zone_profile(level)
        ax1.plot(days, baseline_profile * 100, '--', color=zone_colors[level],
                 alpha=0.5, linewidth=1.5, label=f'{zone_labels[level]} (baseline)')

    # Plot sample zones (solid)
    for level in ZONE_LEVELS_ORDERED:
        sample_profile = sample_config.get_storage_zone_profile(level)
        ax1.plot(days, sample_profile * 100, '-', color=zone_colors[level],
                 linewidth=2, label=f'{zone_labels[level]}')

    ax1.set_xlabel('Day of Year', fontsize=10)
    ax1.set_ylabel('Storage Threshold (% of capacity)', fontsize=10)
    ax1.set_title(f'FFMP Storage Zones\nBest for: {objective_name} = {objective_value:.4f}',
                  fontsize=11)
    ax1.set_xlim(1, 366)
    ax1.set_ylim(0, 105)
    ax1.grid(True, alpha=0.3)

    # Custom legend - only show solid lines (sample) in legend
    handles1, labels1 = ax1.get_legend_handles_labels()
    # Filter to only solid lines (sample values)
    sample_handles = [h for h, l in zip(handles1, labels1) if '(baseline)' not in l]
    sample_labels = [l for l in labels1 if '(baseline)' not in l]
    ax1.legend(sample_handles, sample_labels, loc='lower right', fontsize=8, ncol=2)

    # Add text note about dashed = baseline
    ax1.text(0.02, 0.98, 'Dashed = Baseline, Solid = Best Solution',
             transform=ax1.transAxes, fontsize=8, va='top', ha='left',
             bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))

    # =========================================================================
    # Bottom subplot: MRF Requirements
    # =========================================================================
    ax2 = axes[1]

    # Get MRF baselines for each reservoir
    reservoirs = NYC_RESERVOIRS
    mrf_baseline = []
    mrf_sample = []

    for res in reservoirs:
        # Get baseline MRF
        baseline_mrf = baseline_config.get_constant(f'mrf_baseline_{res}')
        mrf_baseline.append(baseline_mrf)

        # Get sample MRF
        sample_mrf = sample_config.get_constant(f'mrf_baseline_{res}')
        mrf_sample.append(sample_mrf)

    x = np.arange(len(reservoirs))
    width = 0.35

    bars1 = ax2.bar(x - width/2, mrf_baseline, width, label='Baseline', color='gray', alpha=0.7)
    bars2 = ax2.bar(x + width/2, mrf_sample, width, label='Best Solution', color='steelblue')

    # Add value labels on bars
    for bar in bars1:
        height = bar.get_height()
        ax2.text(bar.get_x() + bar.get_width()/2., height,
                 f'{height:.1f}', ha='center', va='bottom', fontsize=8)
    for bar in bars2:
        height = bar.get_height()
        ax2.text(bar.get_x() + bar.get_width()/2., height,
                 f'{height:.1f}', ha='center', va='bottom', fontsize=8)

    ax2.set_xlabel('Reservoir', fontsize=10)
    ax2.set_ylabel('MRF Baseline (MGD)', fontsize=10)
    ax2.set_title('Minimum Release Flow (MRF) Requirements', fontsize=11)
    ax2.set_xticks(x)
    ax2.set_xticklabels([r.capitalize() for r in reservoirs], fontsize=10)
    ax2.legend(loc='upper right', fontsize=9)
    ax2.grid(True, alpha=0.3, axis='y')

    plt.tight_layout()
    return fig


def plot_all_best_solutions_ffmp_mrf(samples, problem, metrics_df, objective_names,
                                      maximize_flags, figsize=(16, 12)):
    """
    Create a multi-panel figure showing FFMP zones and MRF for best solution of each objective.

    Parameters
    ----------
    samples : np.ndarray
        Parameter samples array
    problem : dict
        SALib problem definition
    metrics_df : pd.DataFrame
        DataFrame with metric values
    objective_names : list
        List of objective names
    maximize_flags : list
        List of booleans for optimization direction
    figsize : tuple
        Figure size

    Returns
    -------
    list of matplotlib.figure.Figure
    """
    # Get baseline config
    baseline_config = get_baseline_config()

    # Find best solutions
    best_solutions = find_best_solutions_per_objective(
        metrics_df, objective_names, maximize_flags
    )

    figures = []

    for obj_name, sample_idx in best_solutions.items():
        print(f"  Plotting best solution for {obj_name} (sample {sample_idx})...")

        # Get the config for this sample
        sample_config = get_config_for_sample(samples[sample_idx], problem)

        # Get objective value
        obj_value = metrics_df.loc[sample_idx, obj_name]

        # Create plot
        fig = plot_ffmp_zones_and_mrf(
            sample_config, baseline_config,
            obj_name, obj_value
        )

        figures.append((obj_name, fig))

    return figures


# =============================================================================
# SIMULATION DYNAMICS PLOTTING
# =============================================================================

def get_simulation_output_file(sample_id):
    """Get the output file path for a given sample ID."""
    return SIMULATIONS_DIR / f"sample_{sample_id:06d}.hdf5"


def load_dynamics_for_samples(sample_ids, baseline_file):
    """
    Load simulation dynamics (NYC storage and Montague flow) for multiple samples.
    
    Parameters
    ----------
    sample_ids : list
        List of sample IDs to load
    baseline_file : Path
        Path to baseline output file
    
    Returns
    -------
    dict : {sample_id: {'nyc_storage': Series, 'montague_flow': Series}}
    """
    dynamics = {}
    # Load baseline
    print("  Loading baseline dynamics...")
    try:
        baseline_data = load_simulation_data(str(baseline_file))
        nyc_storage = baseline_data['res_storage'][NYC_RESERVOIRS].sum(axis=1)
        montague_flow = baseline_data['major_flow']['delMontague']
        dynamics['baseline'] = {
            'nyc_storage': nyc_storage,
            'montague_flow': montague_flow,
            'nyc_storage_pct': 100 * nyc_storage / NYC_TOTAL_CAPACITY
        }
    except Exception as e:
        print(f"    Error loading baseline: {e}")
        dynamics['baseline'] = None
    
    # Load each sample
    for sample_id in sample_ids:
        output_file = get_simulation_output_file(sample_id)
        if not output_file.exists():
            print(f"    Sample {sample_id}: output file not found")
            dynamics[sample_id] = None
            continue
        
        try:
            data = load_simulation_data(str(output_file))
            nyc_storage = data['res_storage'][NYC_RESERVOIRS].sum(axis=1)
            montague_flow = data['major_flow']['delMontague']
            dynamics[sample_id] = {
                'nyc_storage': nyc_storage,
                'montague_flow': montague_flow,
                'nyc_storage_pct': 100 * nyc_storage / NYC_TOTAL_CAPACITY
            }
        except Exception as e:
            print(f"    Sample {sample_id}: error loading - {e}")
            dynamics[sample_id] = None
    return dynamics


def find_critical_periods(baseline_dynamics):
    """
    Find the dates of minimum storage and minimum flow in baseline.

    Parameters
    ----------
    baseline_dynamics : dict
        Baseline dynamics with 'nyc_storage' and 'montague_flow'

    Returns
    -------
    dict : {'min_storage_date': date, 'min_flow_date': date}
    """
    min_storage_date = baseline_dynamics['nyc_storage'].idxmin()
    min_flow_date = baseline_dynamics['montague_flow'].idxmin()

    return {
        'min_storage_date': min_storage_date,
        'min_flow_date': min_flow_date
    }


def plot_dynamics_comparison(dynamics, best_solutions, metrics_df, objective_names,
                              start_date, end_date, period_name, figsize=(14, 8),
                              log_flow=True):
    """
    Plot NYC storage and Montague flow dynamics for best solutions vs baseline.

    Parameters
    ----------
    dynamics : dict
        Dictionary of dynamics for each sample and baseline
    best_solutions : dict
        {objective_name: sample_id} for best solutions
    metrics_df : pd.DataFrame
        Metrics dataframe for labeling
    objective_names : list
        List of objective names
    start_date : datetime
        Start date for the plot window
    end_date : datetime
        End date for the plot window
    period_name : str
        Name of the period for the title
    figsize : tuple
        Figure size
    log_flow : bool
        If True, use log scale for Montague flow y-axis

    Returns
    -------
    matplotlib.figure.Figure
    """
    fig, axes = plt.subplots(2, 1, figsize=figsize, sharex=True)

    # Colors for each objective
    colors = plt.cm.tab10(np.linspace(0, 1, len(objective_names)))
    obj_colors = {obj: colors[i] for i, obj in enumerate(objective_names)}

    # =========================================================================
    # Top subplot: NYC Storage
    # =========================================================================
    ax1 = axes[0]

    # Plot baseline (thick black)
    if dynamics['baseline'] is not None:
        baseline_storage = dynamics['baseline']['nyc_storage_pct']
        baseline_storage_window = baseline_storage[
            (baseline_storage.index >= start_date) &
            (baseline_storage.index <= end_date)
        ]
        ax1.plot(baseline_storage_window.index, baseline_storage_window.values,
                 'k-', linewidth=2.5, label='Baseline', zorder=10)

    # Plot best solutions
    for obj_name, sample_id in best_solutions.items():
        if dynamics.get(sample_id) is None:
            continue

        storage = dynamics[sample_id]['nyc_storage_pct']
        storage_window = storage[
            (storage.index >= start_date) &
            (storage.index <= end_date)
        ]

        # Shorten label
        short_label = obj_name.replace('pct_time_', '').replace('_', ' ').title()
        if len(short_label) > 20:
            short_label = short_label[:17] + '...'

        ax1.plot(storage_window.index, storage_window.values,
                 color=obj_colors[obj_name], linewidth=1.5, alpha=0.8,
                 label=f'Best {short_label}')

    ax1.set_ylabel('NYC Storage (% capacity)', fontsize=10)
    ax1.set_title(f'Simulation Dynamics: {period_name}', fontsize=11)
    ax1.legend(loc='lower left', fontsize=8, ncol=2)
    ax1.grid(True, alpha=0.3)
    ax1.set_ylim(0, 105)

    # =========================================================================
    # Bottom subplot: Montague Flow
    # =========================================================================
    ax2 = axes[1]

    # Plot baseline (thick black)
    if dynamics['baseline'] is not None:
        baseline_flow = dynamics['baseline']['montague_flow']
        baseline_flow_window = baseline_flow[
            (baseline_flow.index >= start_date) &
            (baseline_flow.index <= end_date)
        ]
        ax2.plot(baseline_flow_window.index, baseline_flow_window.values,
                 'k-', linewidth=2.5, label='Baseline', zorder=10)

    # Plot best solutions
    for obj_name, sample_id in best_solutions.items():
        if dynamics.get(sample_id) is None:
            continue

        flow = dynamics[sample_id]['montague_flow']
        flow_window = flow[
            (flow.index >= start_date) &
            (flow.index <= end_date)
        ]

        short_label = obj_name.replace('pct_time_', '').replace('_', ' ').title()
        if len(short_label) > 20:
            short_label = short_label[:17] + '...'

        ax2.plot(flow_window.index, flow_window.values,
                 color=obj_colors[obj_name], linewidth=1.5, alpha=0.8,
                 label=f'Best {short_label}')

    ax2.set_xlabel('Date', fontsize=10)
    ax2.set_ylabel('Montague Flow (MGD)', fontsize=10)
    ax2.legend(loc='upper right', fontsize=8, ncol=2)
    ax2.grid(True, alpha=0.3)

    # Use log scale for flow if requested
    if log_flow:
        ax2.set_yscale('log')

    # Format x-axis dates
    fig.autofmt_xdate()

    plt.tight_layout()
    return fig


def plot_best_solutions_dynamics(samples, problem, metrics_df, objective_names,
                                  maximize_flags, baseline_file,
                                  start_date="1980-10-01", end_date="1983-10-01"):
    """
    Create dynamics plots for best solutions over a specified time period.

    Parameters
    ----------
    samples : np.ndarray
        Parameter samples array
    problem : dict
        SALib problem definition
    metrics_df : pd.DataFrame
        Metrics dataframe
    objective_names : list
        List of objective names
    maximize_flags : list
        List of booleans for optimization direction
    baseline_file : Path
        Path to baseline output file
    start_date : str
        Start date for the plot window (default: "1980-10-01")
    end_date : str
        End date for the plot window (default: "1983-10-01")

    Returns
    -------
    matplotlib.figure.Figure or None
    """
    # Find best solutions
    best_solutions = find_best_solutions_per_objective(
        metrics_df, objective_names, maximize_flags
    )

    # Print which sample is best for each objective
    print("  Best solutions per objective:")
    for obj_name, sample_id in best_solutions.items():
        obj_value = metrics_df.loc[sample_id, obj_name]
        print(f"    {obj_name}: sample {sample_id} (value={obj_value:.4f})")

    # Get unique sample IDs
    unique_sample_ids = list(set(best_solutions.values()))

    print(f"  Loading dynamics for {len(unique_sample_ids)} unique samples: {unique_sample_ids}")

    # Load dynamics
    dynamics = load_dynamics_for_samples(unique_sample_ids, baseline_file)

    # Report loading status
    loaded_count = sum(1 for sid in unique_sample_ids if dynamics.get(sid) is not None)
    print(f"  Successfully loaded: {loaded_count}/{len(unique_sample_ids)} samples")

    if dynamics['baseline'] is None:
        print("  ERROR: Could not load baseline dynamics")
        return None

    # Convert date strings to datetime
    import pandas as pd
    start_dt = pd.to_datetime(start_date)
    end_dt = pd.to_datetime(end_date)

    print(f"  Plotting dynamics for period: {start_date} to {end_date}")

    # Create plot
    period_name = f"{start_date} to {end_date}"
    fig = plot_dynamics_comparison(
        dynamics, best_solutions, metrics_df, objective_names,
        start_dt, end_dt, period_name
    )

    return fig


# =============================================================================
# MAIN
# =============================================================================

def main():
    """Run Pareto front analysis."""

    print("=" * 70)
    print("PARETO FRONT ANALYSIS")
    print("=" * 70)

    # Load data
    print("\nLoading data...")
    samples, problem = load_samples("sobol")
    metrics_df = load_metrics()

    n_samples = len(samples)
    n_metrics = len(metrics_df)

    print(f"  Samples: {n_samples}")
    print(f"  Metrics records: {n_metrics}")

    # Check for matching sample counts
    if n_samples != n_metrics:
        print(f"  WARNING: Sample count mismatch. Using minimum.")
        n_use = min(n_samples, n_metrics)
        samples = samples[:n_use]
        metrics_df = metrics_df.iloc[:n_use]

    # Get objectives that exist in metrics
    available_objectives = {k: v for k, v in OBJECTIVES.items()
                           if k in metrics_df.columns}

    if len(available_objectives) < 2:
        print("\nERROR: Need at least 2 objectives for Pareto analysis.")
        print(f"  Available: {list(metrics_df.columns)}")
        print(f"  Configured: {list(OBJECTIVES.keys())}")
        return

    objective_names = list(available_objectives.keys())
    maximize_flags = [available_objectives[k] for k in objective_names]

    print(f"\nObjectives ({len(objective_names)}):")
    for name, maximize in zip(objective_names, maximize_flags):
        direction = "maximize" if maximize else "minimize"
        print(f"  - {name}: {direction}")

    # Find Pareto front
    print("\nFinding Pareto front...")
    pareto_mask = find_pareto_front(metrics_df, objective_names, maximize_flags)

    n_pareto = pareto_mask.sum()
    print(f"  Pareto-optimal solutions: {n_pareto} ({100*n_pareto/len(metrics_df):.1f}%)")

    # Save Pareto front indices
    pareto_indices = np.where(pareto_mask)[0]
    pareto_df = metrics_df.iloc[pareto_indices].copy()
    pareto_df['sample_id'] = pareto_indices

    pareto_file = ANALYSIS_DIR / "pareto_front.csv"
    pareto_df.to_csv(pareto_file, index=False)
    print(f"  Saved Pareto front to: {pareto_file}")

    # Summary statistics
    print("\n" + "-" * 50)
    print("PARETO FRONT SUMMARY")
    print("-" * 50)

    for obj in objective_names:
        all_vals = metrics_df[obj]
        pareto_vals = metrics_df[obj][pareto_mask]
        print(f"\n{obj}:")
        print(f"  All samples:   min={all_vals.min():.4f}, max={all_vals.max():.4f}, mean={all_vals.mean():.4f}")
        print(f"  Pareto front:  min={pareto_vals.min():.4f}, max={pareto_vals.max():.4f}, mean={pareto_vals.mean():.4f}")

    # Get baseline metrics
    print("\nLoading baseline metrics...")
    baseline_metrics = get_baseline_metrics(objective_names)
    if baseline_metrics is not None:
        print("  Baseline metrics:")
        for name, value in baseline_metrics.items():
            print(f"    {name}: {value:.4f}")

    # Generate plots
    print("\n" + "-" * 50)
    print("GENERATING PLOTS")
    print("-" * 50)

    # 1. Parallel coordinates in objective space
    print("\n1. Objectives parallel coordinates plot...")
    fig = plot_objectives_parallel_coordinates(metrics_df, pareto_mask,
                                               objective_names, maximize_flags,
                                               baseline_metrics=baseline_metrics)
    outfile = FIGURES_DIR / "pareto_objectives.png"
    fig.savefig(outfile, dpi=DPI, bbox_inches='tight')
    plt.close(fig)
    print(f"  Saved: {outfile.name}")

    # 2. Parallel coordinates in parameter space
    print("\n2. Parameters parallel coordinates plot...")
    fig = plot_parameters_parallel_coordinates(samples, pareto_mask, problem)
    outfile = FIGURES_DIR / "pareto_parameters.png"
    fig.savefig(outfile, dpi=DPI, bbox_inches='tight')
    plt.close(fig)
    print(f"  Saved: {outfile.name}")

    # 3. Parameter boxplots
    print("\n3. Parameter distribution boxplots...")
    fig = plot_parameter_boxplots(samples, pareto_mask, problem)
    outfile = FIGURES_DIR / "pareto_parameter_boxplots.png"
    fig.savefig(outfile, dpi=DPI, bbox_inches='tight')
    plt.close(fig)
    print(f"  Saved: {outfile.name}")

    # 4. FFMP zones and MRF for best solutions per objective
    print("\n4. FFMP zones and MRF for best solutions...")
    best_figures = plot_all_best_solutions_ffmp_mrf(
        samples, problem, metrics_df, objective_names, maximize_flags
    )
    for obj_name, fig in best_figures:
        # Clean up objective name for filename
        clean_name = obj_name.replace("pct_time_", "").replace("_", "-")
        outfile = FIGURES_DIR / f"best_solution_{clean_name}_ffmp_mrf.png"
        fig.savefig(outfile, dpi=DPI, bbox_inches='tight')
        plt.close(fig)
        print(f"  Saved: {outfile.name}")

    # 5. Simulation dynamics for best solutions
    print("\n5. Simulation dynamics for best solutions...")
    dynamics_fig = plot_best_solutions_dynamics(
        samples, problem, metrics_df, objective_names, maximize_flags,
        BASELINE_OUTPUT_FILE
    )
    if dynamics_fig is not None:
        outfile = FIGURES_DIR / "best_solutions_dynamics.png"
        dynamics_fig.savefig(outfile, dpi=DPI, bbox_inches='tight')
        plt.close(dynamics_fig)
        print(f"  Saved: {outfile.name}")

    print("\n" + "=" * 70)
    print("PARETO ANALYSIS COMPLETE")
    print("=" * 70)
    print(f"\nFigures saved to: {FIGURES_DIR}")
    print(f"Pareto front data saved to: {pareto_file}")


if __name__ == "__main__":
    main()